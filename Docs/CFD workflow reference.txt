Introduction


We’ve made some significant changes to the CFD workflow for 2020. There’s a lot going on, and it might seem like a massive downgrade on the elegant solution we had last year, but the new tools are pretty powerful. 


All the macros have been built under the assumption that sims will be run in batch, and will look for system environment variables for certain operations and parameters. I made some attempt to have control flows to handle missing environment variables, but can’t guarantee the protections cover every possible control flow. The short of that is - these macros are meant for batch. Don’t use them for an interactive session. The majority of the code has been written for Linux. Right now Linux support is guaranteed. Chunks of Windows support are in the code, but it isn’t being maintained, and I don’t plan on maintaining it. Too much work for no functional benefit.  


In terms of sim set-up, it’s exactly the same as last year. All you need to worry about is ensuring all of your geometry is in the ‘parts’ folder in the STAR-CCM+ workflow, and that you don’t touch anything else in the base sim. I’ve made an effort to ensure the simulations are configurable through the macros and the configuration files associated with the Python tools. If more configurability or features are desired, it would be pretty easy to add it, just let me know. The way the macros are set up this time around makes it very easy to add functionality. Where things start diverging is the batch workflow. Last year’s macros could do interactive sessions just fine, so there wasn’t anything to learn. This year is different. You will definitely need some cursory familiarity with bash scripts and the Unix terminal. A little Python exposure wouldn’t hurt either. 

Also, DON'T REUSE SIMULATIONS. Make sure you ALWAYS start from a 0 yaw basesim. There are certain cases where the macros will explode if you run a yaw sim, and use that yaw environment as a starting point for your next simulation. It sucks, and it's probably not a horribly difficult fix, but it's incredibly low priority right now. Just stick with starting every new part revision from a PF20_X-X basesim. 




________________




Adam’s videos


Adam recorded a series of STAR-CCM+ videos a couple years ago. Things have changed quite a bit so they don’t directly apply, but they’re close enough to give a good taste of what STAR-CCM+ looks like. The general order of operations is the same, but don’t blindly copy what he’s doing. It isn’t the same set-up, but it’s enough to figure out the current set-up.


https://drive.google.com/drive/u/0/folders/1aRrgiTWCFij9MXuBym5T0NTADkDQ4NQz




________________




Accessing Scholar


Previously, the goto method of accessing scholar was to use the thinlinc client. Typically the web client over at desktop.scholar.rcac.purdue.edu. Doing this however brings in massive latency annoyances. It’s preferable to access the scholar terminal through your own local Unix terminal of choice. If you have a Mac or a Linux machine, simply open a terminal and enter in ssh username@scholar.rcac.purdue.edu (assuming you have a scholar account). If you have a Windows machine, it is up to you to set up a Unix terminal. My goto was to set up a Ubuntu WSL on Windows 10, before eventually caving in and dual booting Ubuntu proper. Setting up a WSL is however a much easier and less invasive process, and shouldn’t take more than a couple minutes. PuTTY should theoretically work as well. Once you ssh into scholar, you’ll have access to all the same terminal commands as you would with a terminal launched through the thinlinc client. Look into ssh-keygens to store ssh keys so you don’t have to enter in your password every time you ssh into scholar. 


For file access, you could map the rcac drive to your computer exactly the same way you mapped your home purdue drive (details on how can be found on the rcac website), or you can use a SFTP client and use the ssh/SFTP protocol. I’ve had better luck with SFTP since it doesn’t require you to be on a Purdue network. For SFTP, use username@scholar.rcac.purdue.edu. Linux and (I’m guessing) Mac machines should support SFTP natively through the file explorer. Windows requires a separate program (your pick). 


If you absolutely need to have a GUI, use the thinlinc web client. Don’t expect GUI performance to be useable however, and the latency can be anywhere between tolerable and absolutely unusable with the web client. 


There are also plenty of apps for Android/iOS for Unix terminals and SFTP. So if you ever want to check up on a sim on the go, you can, and don’t have to open up thinlinc on a phone browser. 
________________






Installing STAR-CCM+


Here: https://drive.google.com/file/d/1LBcG3mdQAOEri17cIx1lal5zvKczY6uE/view?usp=sharing


If you’re using a cluster, install it to your desktop. Don’t use the default location in /opt/ if it tries to install it to /opt/. Don’t install it to scratch. Install STAR-CCM+ 14.04 (2019.2)


________________


Setting up geometry


Here: https://drive.google.com/file/d/1CpEh1lpEgvu3_-Z-ESMUSlEAD6FXDNhn/view?usp=sharing 


Things look a little different between Adam’s set-up from two years ago and what we have now, but it’s essentially the same workflow. You need to have your parts in the parts folder. How you get them there is up to you depending on your own preferences and how you want to manage your 3D CAD folder. 


NAMING CONVENTION IS IMPORTANT. It’s crucial that all your geometry follows a naming convention. The java code looks for RW, FW, UT, EC, NS, MOUNT, SW, FC, CFD in the part/surface name to determine what part it is. Every time the java code needs to decide what part a given geometry element is, it checks to see if the representation name of the element contains one of those capitalized codes. If you have a new NS, and name it NS_3-1 it’ll be fine. If you have a new RW, and name it n8509_w_lg, it won’t be fine. Same goes for radiators and wheels. 




radiatorName = "CFD_RADIATOR";
dualRadiatorName = "CFD_DUAL_RADIATOR";
liftGeneratorPrefixes = new ArrayList<>();
aeroPrefixes.addAll(Arrays.asList("RW", "FW", "UT", "EC", "NS", "MOUNT", "SW", "FC"));
nonAeroPrefixes.addAll(Collections.singletonList("CFD"));
wheelNames.addAll(Arrays.asList("Front Left", "Front Right", "Rear Left", "Rear Right"));
liftGeneratorPrefixes.addAll(Arrays.asList("RW", "FW", "UT", "SW", "FC"));




________________




Getting the macros


The best way would be to create a GitHub account using your Purdue email (GitHub has a thing for student accounts). Shoot Raunaq a message to get added to the fsaeSTAR github, and pull the master branch (or the alpha branch if you’re adventurous). That ensures you’ve got the latest master branch. 


________________


Configuration flags


The macros expect to be able to pull environment variables for parameters like ride height, and flags which determine which macros will run and which won’t. These configuration flags are detailed in (https://docs.google.com/document/d/1GwEvCaE1URaPwJLXI6nazODZnMNaTUN8bTXONaIzzPY/edit). Every batch script must declare a value for each of these flags.


________________




Writing batch scripts


Option 1 - Write your own


Assuming a certain level of familiarity with bash, it isn’t that difficult to write your own bash scripts. This is probably the most powerful way to run a set of simulations, and is going to yield more control than using a tool to generate the batch files. Important commands to know are the export commands, the qsub command, and the runstar command. 


To set an environment variable, use “export var = val”; For example, your batch script should include “export rrh = 1;” if you want to set your rear ride height to 1 inch above the baseline. 


To reference a variable in a later command, use $VAR. So having $PODKEY in a command after you’ve already run export PODKEY=yourpodkey would replace substitute $PODKEY with your PODKEY


To run a star batch session, the command is - "$STARLOC" "$SIMPATH/$FILENAME" -batch "$CP/$MACRO" -machinefile $PBS_NODEFILE -cpubind -rsh ssh -np $PROCS -podkey $PODKEY -classpath "$CP" -power


Bash is a horrifically difficult language to work with though, but offers far more configurability than we’ll ever get out of an internally built tool to generate batch scripts. Have a look at some of the scripts in the /scripts/ folder to get an idea of what a custom batch script would look like.


Example structure of a shell script (ignore the specific commands, this is a weird windows formatted shell script with a handful of linux file locations):


  
 




Option 2 - Use the python tool


The Python tool tries to take away the work of generating batch files and submitting them to the queue. The tool itself is still under active development, however two components of it have been built. There’s still more work to be done to make the tool smarter, easier to use, and more powerful. 


Right now there are two scripts. folderBuilder.py and csvBuilder.py. Both of them need to be run through python3, and likely will require you to install additional modules beyond what the Unix terminal on scholar already has. 


csvBuilder.py works by taking a spreadsheet input (you’ll have to manually edit the code to give it a file name for the spreadsheet), and uses the inputs in the spreadsheet to generate a single batch file than can be submitted to the job scheduler through a qsub command. Ensure there’s a column for every single flag that’s listed in the “flag list” google doc in the fsae aero folder. There is an example spreadsheet in the /python/ folder. It’s an older one, it might not have all the flags you need. Just go ahead and add new columns. 


folderBuilder.py works by creating a batch file that will handle submitting a job to the cluster, and children batch files that will handle macro execution for the simulations themselves. Currently folderBuilder can generate one batch file for each sim, or one batch file for every sim. folderBuilder.py must be given locations for the folder where the sim files are kept. folderBuilder.py will set environment variables for each simulation based on an inputted configuration file. Everyone should ideally have their own configuration file. Every entry in the flag list document must be in the configuration file. For formatting, look at some of the scripts already in the python folder. Folder builder automatically sets the newName flag. It also requires that there is already a /Processed/ folder in the same directory as your simulation file. 


Example configuration file can be found in linuxConfig in the python folder


  



In either case, it would be a good idea to read through the Python code so you have an idea of what it’s doing. It’s reasonably short. It would also be a good idea to read though the Java macros, but those are pretty heavy and not very easy to digest. 
________________


Appendix


Useful bash commands
* qsub: qsub -q <queue-name> -l nodes=<>:ppn=<>,walltime=<hh:mm:ss> <script_name>
* python3: python3 <filename.py>
* Pip3 (module installs): pip3 <module-name> --user
* All the standard cd, ls, ll commands. 
* Set .sh file to be executable: chmod +x <filename>
